#ifndef MANA_MODELING_UTILITIES_HPP
#define MANA_MODELING_UTILITIES_HPP

#include <osg/ProxyNode>
#include <osg/PagedLOD>
#include <osg/Transform>
#include <osg/Geometry>
#include <osg/Camera>

namespace osgVerse
{
    class MeshTopology;

    struct ConvexHull
    {
        std::vector<osg::Vec3> points;
        std::vector<unsigned int> triangles;
    };

    struct Vec3MapComparer
    {
        bool operator()(const osg::Vec3& key1, const osg::Vec3& key2) const
        {
#if 0
            int x0 = round(key1[0] * 1000.0f), x1 = round(key2[0] * 1000.0f);
            int y0 = round(key1[1] * 1000.0f), y1 = round(key2[1] * 1000.0f);
            int z0 = round(key1[2] * 1000.0f), z1 = round(key2[2] * 1000.0f);
            if (x0 < x1) return true; else if (x0 > x1) return false;
            else if (y0 < y1) return true; else if (y0 > y1) return false;
            else return (z0 < z1);
#else
            return key1 < key2;
#endif
        }
    };

    class MeshCollector : public osg::NodeVisitor
    {
    public:
        MeshCollector();
        void setWeldingVertices(bool b) { _weldVertices = b; }
        void setUseGlobalVertices(bool b) { _globalVertices = b; }
        void setLoadingFineLevels(bool b) { _loadedFineLevels = b; }
        void setOnlyVertexAndIndices(bool b) { _onlyVertexAndIndices = b; }

        inline void pushMatrix(const osg::Matrix& matrix) { _matrixStack.push_back(matrix); }
        inline void popMatrix() { _matrixStack.pop_back(); }
        inline void pushStateSet(osg::StateSet& ss) { _stateSetStack.push_back(&ss); }
        inline void popStateSet() { _stateSetStack.pop_back(); }
        virtual void reset();

        virtual void apply(osg::Node& node);
        virtual void apply(osg::PagedLOD& node);
        virtual void apply(osg::ProxyNode& node);
        virtual void apply(osg::Transform& transform);
        virtual void apply(osg::Geode& node);
        virtual void apply(osg::Geometry& geometry);

        virtual void apply(osg::Node* n, osg::Drawable* d, osg::StateSet& ss);
        virtual void apply(osg::Node* n, osg::Drawable* d, osg::Texture* ss, int u) {}
        
        enum VertexAttribute { WeightAttr, NormalAttr, ColorAttr, UvAttr };
        std::vector<osg::Vec4>& getAttributes(VertexAttribute a) { return _attributes[a]; }
        const std::vector<osg::Vec3>& getVertices() const { return _vertices; }
        const std::vector<unsigned int>& getTriangles() const { return _indices; }
        const osg::BoundingBoxd& getBoundingBox() const { return _boundingBox; }

        std::map<osg::StateSet*, std::vector<size_t>>& getVerticesOfStateSets()
        { return _vertexOfStateSetMap; }
        
        enum NonManifoldType
        {
            IS_MANIFOLD = 0, NONMANIFOLD_EDGE = 1, UNCLOSED_MESH = 2,
            SELF_INTERSECTION = 3, NEGATIVE_VOLUME = 4, UNDEFINED
        };
        NonManifoldType isManifold() const;

    protected:
        typedef std::vector<osg::Matrix> MatrixStack;
        typedef std::vector<osg::StateSet*> StateSetStack;
        MatrixStack _matrixStack;
        StateSetStack _stateSetStack;

        std::map<osg::Vec3, unsigned int, Vec3MapComparer> _vertexMap;
        std::map<VertexAttribute, std::vector<osg::Vec4>> _attributes;
        std::map<osg::StateSet*, std::vector<size_t>> _vertexOfStateSetMap;
        std::vector<osg::Vec3> _vertices;
        std::vector<unsigned int> _indices;
        osg::BoundingBoxd _boundingBox;
        bool _weldVertices, _globalVertices;
        bool _loadedFineLevels, _onlyVertexAndIndices;
    };

    class BoundingVolumeVisitor : public MeshCollector
    {
    public:
        BoundingVolumeVisitor() : MeshCollector() {}

        /** Return value as a set of "near" convex parts, generated by VHACD
            Example resolution settings:
              - Very low: resolution = 500, maxConvexHulls = 1
              - Low: resolution = 2000, maxConvexHulls = 4
              - Medium: resolution = 10000, maxConvexHulls = 8
              - High: resolution = 50000, maxConvexHulls = 20
        */
        osg::Geometry* computeVHACD(bool findBestPlane = false, bool shrinkWrap = true,
                                    int resolution = 10000, int maxConvexHulls = 8, float maxError = 0.0f);

        /** Return value is in OBB coordinates, using rotation to convert it */
        osg::BoundingBox computeOBB(osg::Quat& rotation, float relativeExtent = 0.1f, int numSamples = 500);
    };
    
    class MeshTopologyVisitor : public MeshCollector
    {
    public:
        MeshTopologyVisitor() : MeshCollector() {}
        virtual void apply(osg::Node* n, osg::Drawable* d, osg::StateSet& ss);

        /** Get topology object */
        MeshTopology* generate();
        osg::StateSet* getMergedStateSet() { return _stateset.get(); }

    protected:
        osg::ref_ptr<osg::StateSet> _stateset;
    };

    /** The 2D texture atlaser */
    class TexturePacker : public osg::Referenced
    {
    public:
        TexturePacker(int maxW, int maxH) : _maxWidth(maxW), _maxHeight(maxH), _dictIndex(0) {}
        void setMaxSize(int w, int h) { _maxWidth = w; _maxHeight = h; }
        void clear();

        size_t addElement(osg::Image* image);
        size_t addElement(int width, int height);
        void removeElement(size_t id);

        osg::Image* pack(size_t& numImages, bool generateResult, bool stopIfFailed = false);
        bool getPackingData(size_t id, int& x, int& y, int& w, int& h);

    protected:
        typedef std::pair<osg::observer_ptr<osg::Image>, osg::Vec4> InputPair;
        std::map<size_t, InputPair> _input, _result;
        int _maxWidth, _maxHeight, _dictIndex;
    };

    /** Create a geometry with specified arrays */
    extern osg::Geometry* createGeometry(osg::Vec3Array* va, osg::Vec3Array* na, osg::Vec2Array* ta,
                                         osg::PrimitiveSet* p, bool autoNormals = true, bool useVBO = true);

    extern osg::Geometry* createGeometry(osg::Vec3Array* va, osg::Vec3Array* na, const osg::Vec4& color,
                                         osg::PrimitiveSet* p, bool autoNormals = true, bool useVBO = true);

    /** Create a polar sphere (r1 = r2 = r3) or ellipsoid */
    extern osg::Geometry* createEllipsoid(const osg::Vec3& center, float radius1, float radius2,
                                          float radius3, int samples = 32);

    /** Create a superellipsoid (see http://paulbourke.net/geometry/spherical/) */
    extern osg::Geometry* createSuperEllipsoid(const osg::Vec3& center, float radius, float power1,
                                               float power2, int samples = 32);

    /** Create a prism (n > 3) or cylinder (n is large enough) */
    extern osg::Geometry* createPrism(const osg::Vec3& centerBottom, float radiusBottom, float radiusTop,
                                      float height, int n = 4, bool capped = true);

    /** Create a pyramid (n > 3) or cone (n is large enough) */
    extern osg::Geometry* createPyramid(const osg::Vec3& centerBottom, float radius, float height,
                                        int n = 4, bool capped = false);

    /** Create a view frustum geometry corresponding to given matrices */
    extern osg::Geometry* createViewFrustumGeometry(const osg::Matrix& view, const osg::Matrix& proj);

    /** Create a geodesic sphere which has well-distributed facets */
    extern osg::Geometry* createGeodesicSphere(const osg::Vec3& center, float radius, int iterations = 4);

    /** Create a soccer-like geometry named truncated icosahedron */
    extern osg::Geometry* createSoccer(const osg::Vec3& center, float radius);

    /** Create a textured icosahedron for panorama use */
    extern osg::Geometry* createPanoramaSphere(int subdivs = 2);

    /** Create a bounding volume geometry */
    extern osg::Geometry* createBoundingBoxGeometry(const osg::BoundingBox& bb);
    extern osg::Geometry* createBoundingSphereGeometry(const osg::BoundingSphere& bs);

    /** Change primitives to triangles for GL-Core use */
    extern bool optimizeIndices(osg::Geometry& geom);
}

#endif
