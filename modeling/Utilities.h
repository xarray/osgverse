#ifndef MANA_MODELING_UTILITIES_HPP
#define MANA_MODELING_UTILITIES_HPP

#include <osg/ProxyNode>
#include <osg/PagedLOD>
#include <osg/Transform>
#include <osg/ShapeDrawable>
#include <osg/Geometry>
#include <osg/Camera>

namespace osgVerse
{

    typedef std::pair<osg::Vec2d, size_t> PointType2D;
    typedef std::pair<size_t, size_t> EdgeType;
    typedef std::vector<PointType2D> PointList2D;
    typedef std::vector<osg::Vec3d> PointList3D;
    class MeshTopology;

    struct ConvexHull
    {
        std::vector<osg::Vec3> points;
        std::vector<unsigned int> triangles;
    };

    struct Vec3MapComparer
    {
        bool operator()(const osg::Vec3& key1, const osg::Vec3& key2) const
        {
#if 0
            int x0 = round(key1[0] * 1000.0f), x1 = round(key2[0] * 1000.0f);
            int y0 = round(key1[1] * 1000.0f), y1 = round(key2[1] * 1000.0f);
            int z0 = round(key1[2] * 1000.0f), z1 = round(key2[2] * 1000.0f);
            if (x0 < x1) return true; else if (x0 > x1) return false;
            else if (y0 < y1) return true; else if (y0 > y1) return false;
            else return (z0 < z1);
#else
            return key1 < key2;
#endif
        }
    };

    class NodeVisitorEx : public osg::NodeVisitor
    {
    public:
        NodeVisitorEx();
        inline void pushMatrix(const osg::Matrix& matrix) { _matrixStack.push_back(matrix); }
        inline void popMatrix() { _matrixStack.pop_back(); }
        inline void pushStateSet(osg::StateSet& ss) { _stateSetStack.push_back(&ss); }
        inline void popStateSet() { _stateSetStack.pop_back(); }

        virtual void reset();
        virtual void apply(osg::Node& node);
        virtual void apply(osg::Transform& node);
        virtual void apply(osg::Geode& node);
        virtual void apply(osg::Geometry& geometry);
        virtual void apply(osg::Node* n, osg::Drawable* d, osg::StateSet& ss);
        virtual void apply(osg::Node* n, osg::Drawable* d, osg::Texture* ss, int u) {}

    protected:
        typedef std::vector<osg::Matrix> MatrixStack;
        typedef std::vector<osg::StateSet*> StateSetStack;
        MatrixStack _matrixStack;
        StateSetStack _stateSetStack;
    };

    class MeshCollector : public NodeVisitorEx
    {
    public:
        MeshCollector();
        void setWeldingVertices(bool b) { _weldVertices = b; }
        void setUseGlobalVertices(bool b) { _globalVertices = b; }
        void setLoadingFineLevels(bool b) { _loadedFineLevels = b; }
        void setOnlyVertexAndIndices(bool b) { _onlyVertexAndIndices = b; }

        inline void pushMatrix(const osg::Matrix& matrix) { _matrixStack.push_back(matrix); }
        inline void popMatrix() { _matrixStack.pop_back(); }
        inline void pushStateSet(osg::StateSet& ss) { _stateSetStack.push_back(&ss); }
        inline void popStateSet() { _stateSetStack.pop_back(); }
        virtual void reset();

        virtual void apply(osg::PagedLOD& node);
        virtual void apply(osg::ProxyNode& node);
        virtual void apply(osg::Geode& node);
        virtual void apply(osg::Geometry& geometry);
        
        enum VertexAttribute { WeightAttr, NormalAttr, ColorAttr, UvAttr };
        std::vector<osg::Vec4>& getAttributes(VertexAttribute a) { return _attributes[a]; }
        const std::vector<osg::Vec3>& getVertices() const { return _vertices; }
        const std::vector<unsigned int>& getTriangles() const { return _indices; }
        const osg::BoundingBoxd& getBoundingBox() const { return _boundingBox; }

        typedef std::map<osg::StateSet*, std::vector<size_t>> StateToVerticesMap;
        StateToVerticesMap& getVerticesOfStateSets() { return _vertexOfStateSetMap; }
        std::vector<osg::ref_ptr<osg::Geometry>> output(bool mergeAllStateSets = true);
        
        enum NonManifoldType
        {
            IS_MANIFOLD = 0, NONMANIFOLD_EDGE = 1, UNCLOSED_MESH = 2,
            SELF_INTERSECTION = 3, NEGATIVE_VOLUME = 4, UNDEFINED
        };
        NonManifoldType isManifold() const;

    protected:
        std::map<osg::Vec3, unsigned int, Vec3MapComparer> _vertexMap;
        std::map<VertexAttribute, std::vector<osg::Vec4>> _attributes;
        StateToVerticesMap _vertexOfStateSetMap;
        std::vector<osg::Vec3> _vertices;
        std::vector<unsigned int> _indices;
        osg::BoundingBoxd _boundingBox;
        bool _weldVertices, _globalVertices;
        bool _loadedFineLevels, _onlyVertexAndIndices;
    };

    /** Compute OBB or VHACD bound volumes */
    class BoundingVolumeVisitor : public MeshCollector
    {
    public:
        BoundingVolumeVisitor() : MeshCollector() {}

        /** Return value as a set of "near" convex parts, generated by VHACD
            Example resolution settings:
              - Very low: resolution = 500, maxConvexHulls = 1
              - Low: resolution = 2000, maxConvexHulls = 4
              - Medium: resolution = 10000, maxConvexHulls = 8
              - High: resolution = 50000, maxConvexHulls = 20
        */
        osg::Geometry* computeVHACD(bool findBestPlane = false, bool shrinkWrap = true,
                                    int resolution = 10000, int maxConvexHulls = 8, float maxError = 0.0f);

        /** Return value is in OBB coordinates, using rotation to convert it */
        osg::BoundingBox computeOBB(osg::Quat& rotation, float relativeExtent = 0.1f, int numSamples = 500);
    };

    /** Signed-Distance-Field (SDF) data creator */
    class SDFGridCreator : public MeshCollector
    {
    public:
        struct SDF
        {
            std::vector<std::vector<double>> nodes;
            std::vector<std::vector<std::array<unsigned int, 32>>> cells;
            std::vector<std::vector<unsigned int>> cellMap;
            osg::BoundingBox domain;
            osg::Vec3 cellSize, invCellSize;
            int resolution[3];
        };

        SDFGridCreator() : MeshCollector() {}

        /** Generate SDF grid data */
        bool generate(SDF& sdf, unsigned int resX, unsigned int resY, unsigned int resZ, bool invert = false);

        /** Compute distances of given points to the SDF grid, as well as output normals */
        std::vector<float> computeDistances(const SDF& sdf, const std::vector<osg::Vec3>& pts,
                                            std::vector<osg::Vec3>& normals) const;

        /** Get volume sampling particles of given SDF grid */
        std::vector<osg::Vec3> sampleVolume(const SDF& sdf, float particleRadius, bool denseMode = false) const;
    };

    /** Collect mesh data and create topology object */
    class MeshTopologyVisitor : public MeshCollector
    {
    public:
        MeshTopologyVisitor() : MeshCollector() {}
        virtual void apply(osg::Node* n, osg::Drawable* d, osg::StateSet& ss);

        /** Get topology object */
        MeshTopology* generate();
        osg::StateSet* getMergedStateSet() { return _stateset.get(); }

    protected:
        osg::ref_ptr<osg::StateSet> _stateset;
    };

    /** Temporarily keep the textures on cpu side from being unref-ed */
    class HostTextureReserver : public MeshCollector
    {
    public:
        HostTextureReserver() : MeshCollector() {}
        virtual void apply(osg::Node* n, osg::Drawable* d, osg::Texture* ss, int u);
        void set(bool toKeepHostTextures);

    protected:
        std::map<osg::Texture*, std::pair<bool, bool>> _reservedMap;
    };

    class ShapeGeometryVisitor : public osg::ConstShapeVisitor
    {
    public:
        ShapeGeometryVisitor(osg::Geometry* geometry, const osg::TessellationHints* hints);
        virtual void apply(const osg::Sphere&);
        virtual void apply(const osg::Box&);
        virtual void apply(const osg::Cone&);
        virtual void apply(const osg::Cylinder&);
        virtual void apply(const osg::Capsule&);
        virtual void apply(const osg::InfinitePlane&);
        virtual void apply(const osg::TriangleMesh&);
        virtual void apply(const osg::ConvexHull&);
        virtual void apply(const osg::HeightField&);
        virtual void apply(const osg::CompositeShape&);

        void Normal(const osg::Vec3f& v) { _normals->push_back(v); }
        void Normal3f(float x, float y, float z) { Normal(osg::Vec3(x, y, z)); }
        void TexCoord(const osg::Vec2f& tc) { _texcoords->push_back(tc); }
        void TexCoord2f(float x, float y) { TexCoord(osg::Vec2(x, y)); }
        void Vertex(const osg::Vec3f& v);
        void Vertex3f(float x, float y, float z) { Vertex(osg::Vec3(x, y, z)); }
        void setMatrix(const osg::Matrixd& m);
        void Begin(GLenum mode);
        void End();

    protected:
        ShapeGeometryVisitor& operator = (const ShapeGeometryVisitor&) { return *this; }
        enum SphereHalf { SphereTopHalf, SphereBottomHalf };

        // helpers for apply( Cylinder | Sphere | Capsule )
        void drawCylinderBody(unsigned int numSegments, float radius, float height);
        void drawHalfSphere(unsigned int numSegments, unsigned int numRows, float radius, SphereHalf which, float zOffset = 0.0f);

        osg::Geometry* _geometry;
        const osg::TessellationHints* _hints;
        osg::ref_ptr<osg::Vec3Array>  _vertices;
        osg::ref_ptr<osg::Vec3Array>  _normals;
        osg::ref_ptr<osg::Vec2Array>  _texcoords;
        GLenum          _mode;
        unsigned int    _start_index;
        osg::Matrixd    _matrix;
        osg::Matrixd    _inverse;
    };

    /** Geometry finder */
    class FindGeometryVisitor : public osg::NodeVisitor
    {
    public:
        FindGeometryVisitor(bool applyM)
            : osg::NodeVisitor(osg::NodeVisitor::TRAVERSE_ALL_CHILDREN), _appliedMatrix(applyM) {}
        inline void pushMatrix(osg::Matrix& matrix) { _matrixStack.push_back(matrix); }
        inline void popMatrix() { _matrixStack.pop_back(); }

        virtual void apply(osg::Transform& node);
        virtual void apply(osg::Geode& node);

        std::vector<std::pair<osg::Geometry*, osg::Matrix>>& getGeometries() { return _geomList; }
        const std::vector<std::pair<osg::Geometry*, osg::Matrix>>& getGeometries() const { return _geomList; }

    protected:
        std::vector<osg::Matrix> _matrixStack;
        std::vector<std::pair<osg::Geometry*, osg::Matrix>> _geomList;
        bool _appliedMatrix;
    };

    /** The 2D texture atlaser */
    class TexturePacker : public osg::Referenced
    {
    public:
        TexturePacker(int maxW, int maxH) : _maxWidth(maxW), _maxHeight(maxH), _dictIndex(0) {}
        void setMaxSize(int w, int h) { _maxWidth = w; _maxHeight = h; }
        bool tryPacking();
        void clear();

        size_t addElement(osg::Image* image);
        size_t addElement(int width, int height);
        void removeElement(size_t id);

        osg::Image* pack(size_t& numImages, bool generateResult, bool stopIfFailed = false);
        bool getPackingData(size_t id, int& x, int& y, int& w, int& h);

    protected:
        typedef std::pair<osg::observer_ptr<osg::Image>, osg::Vec4> InputPair;
        std::map<size_t, InputPair> _input, _result;
        int _maxWidth, _maxHeight, _dictIndex;
    };

    /** Create a spline sampler */
    extern PointList3D createBSpline(const PointList3D& ctrlPoints, int numToCreate, int dim = 3);

    /** Create a geometry with specified arrays */
    extern osg::Geometry* createGeometry(osg::Vec3Array* va, osg::Vec3Array* na, osg::Vec2Array* ta, osg::PrimitiveSet* p,
                                         bool autoNormals = true, bool useVBO = true, bool autoOptimize = true);

    extern osg::Geometry* createGeometry(osg::Vec3Array* va, osg::Vec3Array* na, const osg::Vec4& color, osg::PrimitiveSet* p,
                                         bool autoNormals = true, bool useVBO = true, bool autoOptimize = true);

    /** Create a polar sphere (r1 = r2 = r3) or ellipsoid */
    extern osg::Geometry* createEllipsoid(const osg::Vec3& center, float radius1, float radius2,
                                          float radius3, int samples = 32);

    /** Create a superellipsoid (see http://paulbourke.net/geometry/spherical/) */
    extern osg::Geometry* createSuperEllipsoid(const osg::Vec3& center, float radius, float power1,
                                               float power2, int samples = 32);

    /** Create a prism (n > 3) or cylinder (n is large enough) */
    extern osg::Geometry* createPrism(const osg::Vec3& centerBottom, float radiusBottom, float radiusTop,
                                      float height, int n = 4, bool capped = true);

    /** Create a pyramid (n > 3) or cone (n is large enough) */
    extern osg::Geometry* createPyramid(const osg::Vec3& centerBottom, float radius, float height,
                                        int n = 4, bool capped = false);

    /** Create a view frustum geometry corresponding to given matrices */
    extern osg::Geometry* createViewFrustumGeometry(const osg::Matrix& view, const osg::Matrix& proj);

    /** Create a geodesic sphere which has well-distributed facets */
    extern osg::Geometry* createGeodesicSphere(const osg::Vec3& center, float radius, int iterations = 4);

    /** Create a soccer-like geometry named truncated icosahedron */
    extern osg::Geometry* createSoccer(const osg::Vec3& center, float radius);

    /** Create a textured icosahedron for panorama use */
    extern osg::Geometry* createPanoramaSphere(int subdivs = 2);

    /** Create a line-strip/polygon geometry of PointList2D */
    extern osg::Geometry* createPointListGeometry(const PointList2D& points, const osg::Vec4& color,
                                                  bool asPolygon = false, bool closed = false,
                                                  const std::vector<EdgeType>& edges = {});

    /** Create a bounding volume geometry */
    extern osg::Geometry* createBoundingBoxGeometry(const osg::BoundingBox& bb, bool asWireframe);
    extern osg::Geometry* createBoundingSphereGeometry(const osg::BoundingSphere& bs);

    /** Create a 'lathe' geometry by rotating a path about an axis */
    extern osg::Geometry* createLatheGeometry(const PointList3D& ctrlPoints,
                                              const osg::Vec3& axis, int segments = 16,
                                              bool withSplinePoints = false, bool withCaps = true);

    /** Create a 'extrusion' geometry */
    extern osg::Geometry* createExtrusionGeometry(const PointList3D& contours,
                                                  const std::vector<PointList3D>& inners,
                                                  const osg::Vec3& height, bool withSplinePoints = false,
                                                  bool withCaps = true);

    /** Create a 'loft' geometry */
    extern osg::Geometry* createLoftGeometry(const PointList3D& path,
                                             const std::vector<PointList3D>& sections, bool closed = true,
                                             bool withSplinePoints = false, bool withCaps = true);

    /** Change primitives to triangles for GL-Core use */
    extern bool optimizeIndices(osg::Geometry& geom);

    /** Compute total model area and UV area of given drawable's triangles.
        Result can be used to compute texel density (uvArea * w * h / worldArea), etc.
    */
    extern osg::Vec2 computeTotalAreas(osg::Geometry* drawable, int texUnit = 0);

}

#endif
